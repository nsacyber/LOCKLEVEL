#include <windows.h>
#include <intrin.h>
#include <atlstr.h>
#include <comdef.h>
#include <WbemCli.h>
#include <xmllite.h>
#include "banned.h"

#pragma comment(lib, "xmllite.lib")
#pragma comment(lib, "wbemuuid.lib")
#pragma comment(lib, "version.lib")

#define _SDL_BANNED_RECOMMENDED

typedef unsigned __int64 QWORD;

DWORD g_osArch = 0;
IXmlWriter *g_pWriter = NULL;


#define HRESULT_FROM_WIN32(x) ((HRESULT)(x) <= 0 ? ((HRESULT)(x)) \
	: ((HRESULT)(((x)& 0x0000ffff) | (FACILITY_WIN32 << 16) | 0x80000000)))


#pragma warning(disable : 4127)  // conditional expression is constant
#define SAFE_RELEASE(I)         do { if (I){ I->Release(); } I = NULL; } while(0)


// This class is from a Microsoft code sample.
class FileStream : public IStream
{

public:
	FileStream(HANDLE hFile)
	{
		_refcount = 1;
		_hFile = hFile;
	}

	~FileStream()
	{
		if (_hFile != INVALID_HANDLE_VALUE && _hFile != GetStdHandle(STD_OUTPUT_HANDLE))
		{
			::CloseHandle(_hFile);
		}
	}


	HRESULT static OpenFile(LPCWSTR pName, IStream ** ppStream, bool fWrite)
	{
		HANDLE hFile = ::CreateFileW(pName, fWrite ? GENERIC_WRITE : GENERIC_READ, FILE_SHARE_READ,
			NULL, fWrite ? CREATE_ALWAYS : OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile == INVALID_HANDLE_VALUE)
			return HRESULT_FROM_WIN32(GetLastError());

		*ppStream = new FileStream(hFile);

		if (*ppStream == NULL)
			CloseHandle(hFile);

		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, __RPC__deref_out _Result_nullonfailure_ void __RPC_FAR *__RPC_FAR *ppvObject)
	{
		if (!ppvObject)
			return E_INVALIDARG;
		(*ppvObject) = NULL;

		if (iid == __uuidof(IUnknown)
			|| iid == __uuidof(IStream)
			|| iid == __uuidof(ISequentialStream))
		{
			*ppvObject = static_cast<IStream*>(this);
			AddRef();
			return S_OK;
		}
		else
			return E_NOINTERFACE;
	}

	virtual ULONG STDMETHODCALLTYPE AddRef(void)
	{
		return (ULONG)InterlockedIncrement(&_refcount);
	}

	virtual ULONG STDMETHODCALLTYPE Release(void)
	{
		ULONG res = (ULONG)InterlockedDecrement(&_refcount);
		if (res == 0)
			delete this;
		return res;
	}

	// ISequentialStream Interface
public:
	virtual HRESULT STDMETHODCALLTYPE Read(_Out_writes_bytes_to_(cb, *pcbRead) void* pv, _In_ ULONG cb, _Out_opt_ ULONG* pcbRead)
	{
		BOOL rc = ReadFile(_hFile, pv, cb, pcbRead, NULL);
		return (rc) ? S_OK : HRESULT_FROM_WIN32(GetLastError());
	}

	virtual HRESULT STDMETHODCALLTYPE Write(_In_reads_bytes_(cb) const void* pv, _In_ ULONG cb, _Out_opt_ ULONG* pcbWritten)
	{
		BOOL rc = WriteFile(_hFile, pv, cb, pcbWritten, NULL);
		return rc ? S_OK : HRESULT_FROM_WIN32(GetLastError());
	}

	// IStream Interface
public:
	virtual HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE CopyTo(_In_ IStream*, ULARGE_INTEGER, _Out_opt_ ULARGE_INTEGER*, _Out_opt_ ULARGE_INTEGER*)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Commit(DWORD)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Revert(void)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Clone(__RPC__deref_out_opt IStream **)
	{
		return E_NOTIMPL;
	}

	virtual HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER liDistanceToMove, DWORD dwOrigin, _Out_opt_ ULARGE_INTEGER* lpNewFilePointer)
	{
		DWORD dwMoveMethod;

		switch (dwOrigin)
		{
		case STREAM_SEEK_SET:
			dwMoveMethod = FILE_BEGIN;
			break;
		case STREAM_SEEK_CUR:
			dwMoveMethod = FILE_CURRENT;
			break;
		case STREAM_SEEK_END:
			dwMoveMethod = FILE_END;
			break;
		default:
			return STG_E_INVALIDFUNCTION;
			break;
		}

		if (SetFilePointerEx(_hFile, liDistanceToMove, (PLARGE_INTEGER)lpNewFilePointer,
			dwMoveMethod) == 0)
			return HRESULT_FROM_WIN32(GetLastError());
		return S_OK;
	}

	virtual HRESULT STDMETHODCALLTYPE Stat(__RPC__out STATSTG* pStatstg, DWORD)
	{
		if (GetFileSizeEx(_hFile, (PLARGE_INTEGER)&pStatstg->cbSize) == 0)
			return HRESULT_FROM_WIN32(GetLastError());
		return S_OK;
	}

private:
	HANDLE _hFile;
	LONG _refcount;
};


typedef enum
{
	UNSET=0,
	SET,
	NOT_AVAILABLE
} FEATURE_SUPPORT;

#define GET_BIT( reg, bit ) (1UL & (bit ? (((ULONG)reg) >> bit) : (ULONG)reg))


VOID GetAntiExHWSupport(
	FEATURE_SUPPORT *pae,
	FEATURE_SUPPORT *nx,
	FEATURE_SUPPORT *smep,
	FEATURE_SUPPORT *smap
	)
{
	FEATURE_SUPPORT tmp_pae = NOT_AVAILABLE;
	FEATURE_SUPPORT tmp_nx = NOT_AVAILABLE;
	FEATURE_SUPPORT tmp_smep = NOT_AVAILABLE;
	FEATURE_SUPPORT tmp_smap = NOT_AVAILABLE;
	int reg[4] = { 0 };
	ULONG highestLeaf = 0;
	ULONG highestExtendedLeaf = 0;
	ULONG EBX, EDX = 0;

	// We make our cpuid calls in execption handlers in case we
	// send invalid function ID

	// Determine max function IDs
	__try
	{
		__cpuid(reg, 0);
		highestLeaf = (ULONG)reg[0];
		SecureZeroMemory(reg, sizeof(reg));

		__cpuid(reg, (int)0x80000000);
		highestExtendedLeaf = reg[0];
		SecureZeroMemory(reg, sizeof(reg));
	}
	__except (EXCEPTION_EXECUTE_HANDLER) {}


	// Get PAE status
	if (highestLeaf >= 1)
	{
		__try
		{
			__cpuid(reg, 1);
			EDX = (ULONG)reg[3];
			tmp_pae = (FEATURE_SUPPORT)GET_BIT(EDX,6);
			SecureZeroMemory(reg, sizeof(reg));
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {}
	}

	// Get NX status
	if (highestExtendedLeaf >= 0x80000001UL)
	{
		__try
		{
			__cpuid(reg, (int) 0x80000001UL );
			EDX = (ULONG)reg[3];
			tmp_nx = (FEATURE_SUPPORT)GET_BIT(EDX, 20);
			SecureZeroMemory(reg, sizeof(reg));
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {}
	}

	// Get SMEP/SMAP status
	if (highestLeaf >= 7)
	{
		__try
		{
			__cpuid(reg, 7);
			EBX = (ULONG)reg[1];
			tmp_smep = (FEATURE_SUPPORT)GET_BIT(EBX, 7);
			tmp_smap = (FEATURE_SUPPORT)GET_BIT(EBX, 20);
			SecureZeroMemory(reg, sizeof(reg));
		}
		__except (EXCEPTION_EXECUTE_HANDLER) {}
	}


	*pae = tmp_pae;
	*nx = tmp_nx;
	*smep = tmp_smep;
	*smap = tmp_smap;
}

DWORD ReadHKLMRegistryValue(
	IN LPWSTR path,
	IN LPWSTR valueName,
	OUT LPBYTE data,
	IN OUT LPDWORD cbSize
	)
{
	HKEY hKey = NULL;
	DWORD type = 0;

	LSTATUS status = RegOpenKeyW(HKEY_LOCAL_MACHINE, path, &hKey);

	if (ERROR_SUCCESS != (DWORD)status)
		return status;

	status = RegQueryValueExW(hKey, valueName, NULL, &type, data, cbSize);

	RegCloseKey(hKey);

	return (DWORD)status;
}

DWORD GetControlFlowGuard(IN OUT LPBOOL enabled)
{
	BOOL tmpEnabled = FALSE;
	DWORD value = 0;
	DWORD size = sizeof(value);
	DWORD result = 0;

	result = ReadHKLMRegistryValue(L"System\\CurrentControlSet\\Control\\Session Manager\\Memory Management", L"EnableCfg", (LPBYTE)&value, &size);

	if (ERROR_SUCCESS == result) {
		tmpEnabled = (value == 1);
	}

	if(enabled)
		*enabled = tmpEnabled;

	return result;
}

DWORD GetFontBlocking() 
{
	DWORD fontBlocking = 0;

	WCHAR value[MAX_PATH] = {0};
	DWORD size = sizeof(WCHAR) * (MAX_PATH-1);
	DWORD result = 0;

	// Windows 10 RTM uses "FontBocking" instead of "FontBlocking"

	result = ReadHKLMRegistryValue(L"Software\\Policies\\Microsoft\\Windows NT\\MitigationOptions", L"MitigationOptions_FontBocking", (LPBYTE)&value, &size);

	if (ERROR_SUCCESS == result) {
		if(0 == wcscmp(L"1000000000000", value)) 
		{
			fontBlocking = 1;
		}
		else if(0 == wcscmp(L"2000000000000", value))
		{
			fontBlocking = 2;
		}
		else if (0 == wcscmp(L"3000000000000", value)) 
		{
			fontBlocking = 3;
		}
	}

	return fontBlocking;
}

BOOL GetSecureBootEnabled()
{
	BOOL enabled = FALSE;
	DWORD state = 0;
	DWORD size = sizeof(state);
	DWORD result = 0;

	result = ReadHKLMRegistryValue(L"SYSTEM\\CurrentControlSet\\Control\\SecureBoot\\State", L"UEFISecureBootEnabled", (LPBYTE)&state, &size);

	if (ERROR_SUCCESS == result)
	{
		enabled = (state == 1);
	}
	
	return enabled;
}

BOOL GetFirmwarePrivilege()
{
	BOOL result = FALSE;
	HANDLE processToken = NULL;
	TOKEN_PRIVILEGES privileges = {0};
	HANDLE process = GetCurrentProcess();
	LUID luid = {0};

	if(OpenProcessToken(process, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &processToken))
	{
		if(LookupPrivilegeValue(NULL, SE_SYSTEM_ENVIRONMENT_NAME, &luid))
		{
			privileges.PrivilegeCount = 1;
			privileges.Privileges[0].Luid = luid;
			privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

			if(AdjustTokenPrivileges(processToken, FALSE, &privileges, sizeof(TOKEN_PRIVILEGES), NULL, 0))
			{
				result = TRUE;
			}
		}

		CloseHandle(processToken);
	}

	CloseHandle(process);

	return result;
}

typedef DWORD (WINAPI *pfnGetFirmwareEnvironmentVariable)(
	_In_ LPCTSTR lpName, 
	_In_ LPCTSTR lpGuid, 
	_Out_ PVOID pBuffer, 
	_In_ DWORD nSize);

DWORD GetFirmwareType(LPWSTR *firmwareType) 
{
	DWORD result = ERROR_INVALID_DATA;
	DWORD lastError = 0;
	LPWSTR tmpFirmwareType = L"Unknown";

	pfnGetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariable = (pfnGetFirmwareEnvironmentVariable)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "GetFirmwareEnvironmentVariableW");

	if(GetFirmwareEnvironmentVariable)
	{
		result = GetFirmwareEnvironmentVariable(L"", L"{00000000-0000-0000-0000-000000000000}", NULL, 0);
		lastError = GetLastError();

		if (0 == result) {
			if(ERROR_INVALID_FUNCTION == lastError) {
				tmpFirmwareType = L"Legacy";
			}
			else if (ERROR_NOACCESS == lastError) {
				tmpFirmwareType = L"UEFI";
			}
		}
	}

	if (firmwareType) 
		*firmwareType = tmpFirmwareType;

	return result;
}

DWORD GetMemoryOverwriteRequestControlVariableData(LPCTSTR name, LPCTSTR guid, IN OUT LPDWORD value)
{
	DWORD lastError = ERROR_INVALID_DATA;
	DWORD result = 0;

	unsigned __int8 data = 0;
	DWORD size = sizeof(data);

	if (GetFirmwarePrivilege()) {
		pfnGetFirmwareEnvironmentVariable GetFirmwareEnvironmentVariable = (pfnGetFirmwareEnvironmentVariable)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "GetFirmwareEnvironmentVariableW");

		if (GetFirmwareEnvironmentVariable)
		{
			//https://msdn.microsoft.com/windows/hardware/drivers/bringup/device-guard-requirements - looks like Get always returns a 1 byte value while Set can accept 1 byte (V1) or 8 byte value (V2)
			result = GetFirmwareEnvironmentVariable(name, guid, &data, size);
			lastError = GetLastError();

			if (0 == result) {
				/**
				if (ERROR_INVALID_FUNCTION == lastError) { //legacy
				}
				else if (ERROR_NOACCESS == lastError) {
				} 
				else if (ERROR_INSUFFICIENT_BUFFER == lastError) { //need larger buffer to store retrieved data
				}
				else if (ERROR_ENVVAR_NOT_FOUND == lastError) {  //typo in UEFI variable GUID or name
				}
				else if (ERROR_PRIVILEGE_NOT_HELD == lastError) { //GetFirmwarePrivilege failed but didn't return false
				}
				else {
					//wprintf_s(L"Unknown error: (%d) 0x%08X \r\n", lastError, lastError);
				}
				**/
			}
			else { // result == size
				if (value)
					*value = data;
			}
		}
	}

	return lastError;
}

DWORD GetDepPolicy(DEP_SYSTEM_POLICY_TYPE *pPolicy)
{
	DEP_SYSTEM_POLICY_TYPE(WINAPI *pGetSystemDEPPolicy)() = NULL;
	DEP_SYSTEM_POLICY_TYPE tmpPolicy = DEPTotalPolicyCount;
	HKEY hKey = NULL;
	DWORD ret = 0;
	WCHAR startOptions[MAX_PATH] = { 0 };
	PWCHAR noExecute = NULL;
	PWCHAR lpwstrPolicy = NULL;
	PWCHAR context = NULL;
	DWORD size = 0;


	*(VOID **)&pGetSystemDEPPolicy =
		GetProcAddress(GetModuleHandleA("Kernel32.dll"), "GetSystemDEPPolicy");

	if (pGetSystemDEPPolicy)
	{
		*pPolicy = pGetSystemDEPPolicy();
		return ERROR_SUCCESS;
	}

	// System does not have GetSystemDEPPolicy. Go get the DEP policy
	// out of the registry.

	ret = (DWORD)RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control", &hKey);

	if (ret) 
		return ret;

	size = (MAX_PATH - 1)*sizeof(WCHAR);

	ret = (DWORD)RegQueryValueExW(
		hKey,
		L"SystemStartOptions",
		0,
		NULL,
		(PBYTE)startOptions,
		&size
		);

	RegCloseKey(hKey);

	if (ret) 
		return ret;

	for (DWORD i = 0; i < wcslen(startOptions); i++) 
		startOptions[i] = towupper(startOptions[i]);

	noExecute = wcsstr(startOptions, L"NOEXECUTE=");

	if (!noExecute)
		return ERROR_NOT_FOUND;

	lpwstrPolicy = wcstok_s(noExecute + 10, L" \t", &context);

	if (!lpwstrPolicy)
		return ERROR_NOT_FOUND;

	if (0 == wcscmp(L"ALWAYSOFF", lpwstrPolicy))
		tmpPolicy = DEPPolicyAlwaysOff;

	if (0 == wcscmp(L"ALWAYSON", lpwstrPolicy))
		tmpPolicy = DEPPolicyAlwaysOn;

	if (0 == wcscmp(L"OPTIN", lpwstrPolicy))
		tmpPolicy = DEPPolicyOptIn;

	if (0 == wcscmp(L"OPTOUT", lpwstrPolicy))
		tmpPolicy = DEPPolicyOptOut;

	if (tmpPolicy == DEPTotalPolicyCount)
		return ERROR_NOT_FOUND;

	*pPolicy = tmpPolicy;
	return ERROR_SUCCESS;
}

HRESULT DoWmiQuery(
	IWbemServices *pSvc,
	PWCHAR wmiClass,
	PWCHAR propertyName,
	BOOL return1Result,
	PWCHAR *propertyValue
	)
{
	HRESULT hres;
	IEnumWbemClassObject* pEnumerator = NULL;
	IWbemClassObject *pclsObj = NULL;
	ULONG uReturn = 0;
	BOOL valueAppended = FALSE;
	CString values(L"");
	BSTR query = NULL;
	BSTR wql = NULL;
	WCHAR buf[MAX_PATH] = { 0 };


	swprintf_s(buf, MAX_PATH - 1, L"SELECT * FROM %s", wmiClass);
	query = SysAllocString(buf);
	wql = SysAllocString(L"WQL");

	if (!query || !wql)
	{
		hres = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		goto DONE;
	}

	// Use the IWbemServices pointer to make requests of WMI
	hres = pSvc->ExecQuery(
		wql,
		query,
		WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
		NULL,
		&pEnumerator);

	if (FAILED(hres))
		goto DONE;

	// Get the data from the query 
	while (pEnumerator)
	{
		hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);

		if (!uReturn)
			break;

		VARIANT vtProp;
		VariantInit(&vtProp);

		hres = pclsObj->Get(propertyName, 0, &vtProp, 0, 0);

		if (FAILED(hres))
			continue;

		if (vtProp.vt != VT_BSTR)
		{
			pclsObj->Release();
			pclsObj = NULL;
			VariantClear(&vtProp);
			continue;
		}

		if (valueAppended)
			values.Append(L"\n");

		values.Append(vtProp.bstrVal);
		valueAppended = TRUE;

		pclsObj->Release();
		pclsObj = NULL;
		VariantClear(&vtProp);

		if (return1Result)
			break;

	} // end while (pEnumerator)

	if (values.GetLength() > 0)
	{
		*propertyValue = _wcsdup(values.GetString());
		hres = S_OK;
	}
	else
	{
		hres = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
	}

DONE:
	if (query)
		SysFreeString(query);

	if (wql)
		SysFreeString(wql);

	if (pEnumerator)
		pEnumerator->Release();

	return hres;
}

HRESULT CheckforPatches(
	IN IWbemServices *pSvc,
	IN LPWSTR *hotFixIdsArray,
	IN DWORD numPatches,
	OUT BOOL *isPresentArray
	)
{
	HRESULT hres;
	IEnumWbemClassObject* pEnumerator = NULL;
	IWbemClassObject *pclsObj = NULL;
	ULONG uReturn = 0;
	BSTR query = NULL;
	BSTR wql = NULL;
	DWORD i = 0;

	SecureZeroMemory(isPresentArray, numPatches * sizeof(BOOL));

	query = SysAllocString(L"SELECT * FROM Win32_QuickFixEngineering");
	wql = SysAllocString(L"WQL");

	if (!query || !wql)
	{
		hres = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		goto DONE;
	}

	hres = pSvc->ExecQuery(
		wql,
		query,
		WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
		NULL,
		&pEnumerator);

	if (FAILED(hres))
		goto DONE;

	// Get the data from the query 
	while (pEnumerator)
	{
		hres = pEnumerator->Next(WBEM_INFINITE, 1, &pclsObj, &uReturn);

		if (!uReturn)
			break;

		VARIANT vtProp;
		VariantInit(&vtProp);

		hres = pclsObj->Get(L"HotFixID", 0, &vtProp, 0, 0);

		if (FAILED(hres))
			continue;

		if (vtProp.vt == VT_BSTR)
		{
			// Now check whether this patch is listed in our
			// ID array
			for (i = 0; i < numPatches; i++)
			{
				if (0 == _wcsicmp(vtProp.bstrVal, hotFixIdsArray[i]))
				{
					isPresentArray[i] = TRUE;
				}

				// There are reports that sometimes the hotfix ID returned from WMI may
				// omit the initial "KB". So we repeat the comparison excluding the KB
				else if (0 == _wcsicmp(L"KB", hotFixIdsArray[i]) &&
					0 == _wcsicmp(vtProp.bstrVal, hotFixIdsArray[i]+2))
				{
					isPresentArray[i] = TRUE;
				}
			}
		}

		pclsObj->Release();
		pclsObj = NULL;
		VariantClear(&vtProp);


	} // end while (pEnumerator)

	hres = S_OK;
DONE:
	if (query)
		SysFreeString(query);

	if (wql)
		SysFreeString(wql);

	if (pEnumerator)
		pEnumerator->Release();

	return hres;
}

//
// A list of executables to check for certain anti-exploitation features.
// The initial version of this list was abstracted from
// EMET configuration files. Each entry below gives a 
// directory and an executable name. We search for given 
// directories under Program Files and under Program Files 
// (x86). For each found directory we search the file system 
// tree from this directory looking for executables of the 
// given name.
//
WCHAR *appsToCheck[][2] = 
{
	// Archive
	{ L"WinRAR", L"winrar.exe" },
	{ L"WinRAR", L"rar.exe" },
	{ L"WinRAR", L"unrar.exe" },
	{ L"WinZip", L"winzip32.exe" },
	{ L"WinZip", L"winzip64.exe" },
	{ L"7-Zip", L"7z.exe" },
	{ L"7-Zip", L"7zG.exe" },
	{ L"7-Zip", L"7zFM.exe" },

	// Browsers
	{ L"Internet Explorer", L"iexplore.exe" },
	{ L"Google", L"chrome.exe" },
	{ L"Mozilla Firefox", L"firefox.exe" },
	{ L"Mozilla Firefox", L"plugin-container.exe" },
	{ L"Mozilla Thunderbird", L"thunderbird.exe" },
	{ L"Mozilla Thunderbird", L"plugin-container.exe" },
	{ L"Opera", L"opera.exe" },
	{ L"Safari", L"Safari.exe" },

	// Communication
	{ L"Skype", L"Skype.exe" },
	{ L"Microsoft Lync", L"communicator.exe" },
	{ L"Windows Live", L"wlmail.exe" },
	{ L"Microsoft Office", L"OUTLOOK.EXE" },
	{ L"Microsoft Office", L"LYNC.EXE" },
	{ L"Google", L"googletalk.exe" },
	{ L"mIRC", L"mirc.exe" },
	{ L"Pidgin", L"pidgin.exe" },

	// Document viewers/editors
	{ L"Windows Live", L"WindowsLiveWriter.exe"},
	{ L"Microsoft Office", L"WINWORD.EXE"},
	{ L"Microsoft Office", L"EXCEL.EXE"},
	{ L"Microsoft Office", L"POWERPNT.EXE"},
	{ L"Microsoft Office", L"MSPUB.EXE"},
	{ L"Microsoft Office", L"INFOPATH.EXE"},
	{ L"Microsoft Office", L"VISIO.EXE"},
	{ L"Microsoft Office", L"PPTVIEW.EXE"},
	{ L"Adobe", L"AcroRd32.exe"},
	{ L"Adobe", L"Acrobat.exe"},
	{ L"Foxit Reader", L"Foxit Reader.exe" },

	// Media viewers/players
	{ L"Windows Media Player", L"wmplayer.exe"},
	{ L"Windows Live", L"WLXPhotoGallery.exe"},
	{ L"Microsoft Office", L"OIS.EXE"},
	{ L"Adobe", L"Photoshop.exe"},
	{ L"Winamp", L"winamp.exe"},
	{ L"VideoLAN", L"vlc.exe" },
	{ L"Real", L"realconverter.exe" },
	{ L"Real", L"realplay.exe" },
	{ L"QuickTime", L"QuickTimePlayer.exe" },
	{ L"iTunes", L"iTunes.exe" },

	// Misc
	{ L"SkyDrive", L"SkyDrive.exe"},
	{ L"Microsoft Office", L"MSACCESS.EXE"},
	{ L"Java", L"java.exe" },
	{ L"Java", L"javaw.exe" },
	{ L"Java", L"javaws.exe" },

};

typedef struct _PEINFO {
    WORD Machine;
    DWORD Timestamp;
    WORD Characteristics;
    WORD Magic;
    BYTE MajorLinker;
    BYTE MinorLinker;
    WORD MajorOS;
    WORD MinorOS;
    WORD MajorImage;
    WORD MinorImage;
    WORD MajorSubsystem;
    WORD MinorSubsystem;
    WORD Subsystem;
    WORD DllCharacteristics; 
} PEINFO, *PPEINFO, *LPPEINFO;

DWORD GetPEHeaderData(LPWSTR filePath, PPEINFO peInfo)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	PWCHAR pExtension = NULL;
	HANDLE hMapping = NULL;
	DWORD dwRet = ERROR_SUCCESS;
	PBYTE pFile = NULL;
	DWORD fileSizeLow = 0;
	DWORD fileSizeHigh = 0;
	DWORD sizeToMap = 0;
	PIMAGE_NT_HEADERS ntHeaders = {0};
	BOOL is64Bits = FALSE;
	IMAGE_OPTIONAL_HEADER32 header32 = {0};
	IMAGE_OPTIONAL_HEADER64 header64 = {0};
	PEINFO tmpPEInfo = {0};

	pExtension = wcsrchr(filePath, L'.');

	if (!pExtension || 0 != _wcsicmp(pExtension, L".exe"))
		return ERROR_BAD_FORMAT;

	// Verify file exists
	if (INVALID_FILE_ATTRIBUTES == GetFileAttributesW(filePath))
		return GetLastError();

	hFile = CreateFileW(
		filePath,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);

	if (hFile == INVALID_HANDLE_VALUE)
		return GetLastError();

	hMapping = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

	if (!hMapping)
	{
		dwRet = GetLastError();
		goto DONE;
	}

	// Map at most 0x3000 bytes.
	fileSizeLow = GetFileSize(hFile, &fileSizeHigh);
	sizeToMap = 0;

	if (fileSizeHigh || fileSizeLow > 0x3000)
		sizeToMap = 0x3000;

	pFile = (PBYTE)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, sizeToMap);

	if (!pFile)
	{
		dwRet = GetLastError();
		goto DONE;
	}

	__try
	{
		ntHeaders = (PIMAGE_NT_HEADERS)(pFile + ((PIMAGE_DOS_HEADER)pFile)->e_lfanew);

		tmpPEInfo.Machine = ntHeaders->FileHeader.Machine;
		tmpPEInfo.Timestamp =ntHeaders->FileHeader.TimeDateStamp;
		tmpPEInfo.Characteristics = ntHeaders->FileHeader.Characteristics;

		switch (tmpPEInfo.Machine)
		{
		case IMAGE_FILE_MACHINE_I386:
		case IMAGE_FILE_MACHINE_ARM:
			header32 = *((IMAGE_OPTIONAL_HEADER32 *)(&ntHeaders->OptionalHeader));
			break;
		case IMAGE_FILE_MACHINE_AMD64:
		case IMAGE_FILE_MACHINE_IA64:
			header64 = *((IMAGE_OPTIONAL_HEADER64 *)(&ntHeaders->OptionalHeader));
			is64Bits = TRUE;
			break;
		default:
			dwRet = ERROR_NOT_SUPPORTED;
		}

		if (is64Bits)
		{
			tmpPEInfo.Magic = header64.Magic;
			tmpPEInfo.MajorLinker = header64.MajorLinkerVersion;
			tmpPEInfo.MinorLinker = header64.MinorLinkerVersion;
			tmpPEInfo.MajorOS = header64.MajorOperatingSystemVersion;
			tmpPEInfo.MinorOS = header64.MinorOperatingSystemVersion;
			tmpPEInfo.MajorImage = header64.MajorImageVersion;
			tmpPEInfo.MinorImage = header64.MinorImageVersion;
			tmpPEInfo.MajorSubsystem = header64.MajorSubsystemVersion;
			tmpPEInfo.MinorSubsystem = header64.MinorSubsystemVersion;
			tmpPEInfo.Subsystem = header64.Subsystem;
			tmpPEInfo.DllCharacteristics = header64.DllCharacteristics;
		}
		else
		{
			tmpPEInfo.Magic = header32.Magic;
			tmpPEInfo.MajorLinker = header32.MajorLinkerVersion;
			tmpPEInfo.MinorLinker = header32.MinorLinkerVersion;
			tmpPEInfo.MajorOS = header32.MajorOperatingSystemVersion;
			tmpPEInfo.MinorOS = header32.MinorOperatingSystemVersion;
			tmpPEInfo.MajorImage = header32.MajorImageVersion;
			tmpPEInfo.MinorImage = header32.MinorImageVersion;
			tmpPEInfo.MajorSubsystem = header32.MajorSubsystemVersion;
			tmpPEInfo.MinorSubsystem = header32.MinorSubsystemVersion;
			tmpPEInfo.Subsystem = header32.Subsystem;
			tmpPEInfo.DllCharacteristics = header32.DllCharacteristics;
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		dwRet = GetExceptionCode();
		goto DONE;
	}

	*peInfo = tmpPEInfo;

	dwRet = ERROR_SUCCESS;

DONE:
	if (pFile)
		UnmapViewOfFile(pFile);

	if (hMapping)
		CloseHandle(hMapping);

	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);

	return dwRet;
}

DWORD GetAppCompatDEPSetting(LPWSTR filePath, BOOL bAppIs64Bit, PWCHAR *pSetting)
{
	HKEY hKey = NULL;
	BOOL osIs64Bits = FALSE;
	DWORD layersIndex = 0;
	DWORD status = 0;
	WCHAR nxValue[MAX_PATH] = { 0 };
	DWORD size = 0;
	DWORD type = 0;

	WCHAR *Layers[2] =
	{
		L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers",
		L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers",
	};

	osIs64Bits = (g_osArch == PROCESSOR_ARCHITECTURE_AMD64 ||
		g_osArch == PROCESSOR_ARCHITECTURE_IA64);

	if (osIs64Bits && !bAppIs64Bit) 
		layersIndex = 1;

	status = RegOpenKeyW(HKEY_LOCAL_MACHINE, Layers[layersIndex], &hKey);

	if (status != ERROR_SUCCESS) 
		return (DWORD) status;

	size = sizeof(WCHAR)* (MAX_PATH - 1);
	status = RegQueryValueEx(hKey, filePath, NULL, &type, (LPBYTE)nxValue, &size);

	RegCloseKey(hKey);

	if (status != ERROR_SUCCESS) 
		return status;

	*pSetting = _wcsdup(nxValue);

	return ERROR_SUCCESS;
}


#define IFEO_EXECUTEOPTIONS_EXISTS 1
#define IFEO_MITIGATIONOPTIONS_EXISTS 2
#define IFEO_DISABLEEXCEPTIONCHAINVALIDATION_EXISTS 4
#define IFEO_ENABLELOWVAACCESS_EXISTS 8
#define IFEO_CWDILLEGALINDLLSEARCH 16

DWORD GetAppIFEOMitigations(
	IN LPWSTR filePath,
	IN BOOL bAppIs64Bit,
	OUT DWORD *dwConfiguredMitigations,
	OUT DWORD *dwExecuteOptions,
	OUT QWORD *qwMitigationOptions,
	OUT DWORD *dwDisableExceptionChainValidation,
	OUT DWORD *dwEnableLowVaAccess,
	OUT DWORD *dwCWDIllegalInDllSearch
	)
{
	BOOL osIs64Bits = FALSE;
	WCHAR regPath[MAX_PATH] = { 0 };
	PWCHAR fileName = NULL;
	DWORD regPathIndex = 0;
	HKEY hKey = NULL;
	LONG status = 0;
	DWORD size = 0;
	DWORD dwTmpExecuteOptions = 0;
	QWORD qwTmpMitigationOptions = 0;
	DWORD dwTmpDisableExceptionChainValidation = 0;
	DWORD dwTmpEnableLowVaAccess = 0;
	DWORD dwTmpConfiguredMitigations = 0;
	DWORD dwTmpCWDIllegalInDllSearch = 0;


	WCHAR *IFEO[2] =
	{
		L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options",
		L"SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options"
	};

	// Build the registry path. The key name under IFEO is the executable name

	fileName = wcsrchr(filePath, L'\\');

	if (fileName)
		fileName++;
	else
		fileName = filePath;

	osIs64Bits = (g_osArch == PROCESSOR_ARCHITECTURE_AMD64 ||
		g_osArch == PROCESSOR_ARCHITECTURE_IA64);

	if (osIs64Bits && !bAppIs64Bit)
		regPathIndex = 1;

	swprintf_s(regPath, MAX_PATH - 1, L"%s\\%s", IFEO[regPathIndex], fileName);

	status = RegOpenKeyW(HKEY_LOCAL_MACHINE, regPath, &hKey);

	if (status != ERROR_SUCCESS) 
		return (DWORD)status;

	size = sizeof(dwTmpExecuteOptions);
	status = RegQueryValueExW(hKey, L"ExecuteOptions", NULL, NULL, (LPBYTE)&dwTmpExecuteOptions, &size);

	if (status == ERROR_SUCCESS)
		dwTmpConfiguredMitigations |= IFEO_EXECUTEOPTIONS_EXISTS;

	size = sizeof(qwTmpMitigationOptions);
	status = RegQueryValueExW(hKey, L"MitigationOptions", NULL, NULL, (LPBYTE)&qwTmpMitigationOptions, &size);

	if (status == ERROR_SUCCESS)
		dwTmpConfiguredMitigations |= IFEO_MITIGATIONOPTIONS_EXISTS;
	
	size = sizeof(dwTmpDisableExceptionChainValidation);
	status = RegQueryValueExW(hKey, L"DisableExceptionChainValidation", NULL, NULL, (LPBYTE)&dwTmpDisableExceptionChainValidation, &size);

	if (status == ERROR_SUCCESS)
		dwTmpConfiguredMitigations |= IFEO_DISABLEEXCEPTIONCHAINVALIDATION_EXISTS;

	size = sizeof(dwTmpEnableLowVaAccess);
	status = RegQueryValueExW(hKey, L"EnableLowVaAccess", NULL, NULL, (LPBYTE)&dwTmpEnableLowVaAccess, &size);

	if (status == ERROR_SUCCESS)
		dwTmpConfiguredMitigations |= IFEO_ENABLELOWVAACCESS_EXISTS;

	size = sizeof(dwTmpCWDIllegalInDllSearch);
	status = RegQueryValueExW(hKey, L"CWDIllegalInDllSearch", NULL, NULL, (LPBYTE)&dwTmpCWDIllegalInDllSearch, &size);

	if (status == ERROR_SUCCESS)
		dwTmpConfiguredMitigations |= IFEO_CWDILLEGALINDLLSEARCH;

	if (dwTmpConfiguredMitigations | IFEO_EXECUTEOPTIONS_EXISTS)
		*dwExecuteOptions = dwTmpExecuteOptions;

	if (dwTmpConfiguredMitigations | IFEO_MITIGATIONOPTIONS_EXISTS)
		*qwMitigationOptions = qwTmpMitigationOptions;

	if (dwTmpConfiguredMitigations | IFEO_DISABLEEXCEPTIONCHAINVALIDATION_EXISTS)
		*dwDisableExceptionChainValidation = dwTmpDisableExceptionChainValidation;

	if (dwTmpConfiguredMitigations | IFEO_ENABLELOWVAACCESS_EXISTS)
		*dwEnableLowVaAccess = dwTmpEnableLowVaAccess;

	if (dwTmpCWDIllegalInDllSearch | IFEO_CWDILLEGALINDLLSEARCH)
		*dwCWDIllegalInDllSearch = IFEO_CWDILLEGALINDLLSEARCH;

	*dwConfiguredMitigations = dwTmpConfiguredMitigations;

	RegCloseKey(hKey);
	return ERROR_SUCCESS;
}

typedef VOID(*TRAVERSAL_CALLBACK)(LPWSTR filePath);

VOID OutputAppMitigations_callback(LPWSTR filePath)
{
	PEINFO peInfo = {0};
	BOOL is64Bits = FALSE;

	PWCHAR pSetting = NULL;
	DWORD dwConfiguredMitigations = 0;
	DWORD dwExecuteOptions = 0;
	QWORD qwMitigationOptions = 0;
	DWORD dwDisableExceptionChainValidation = 0;
	DWORD dwEnableLowVaAccess = 0;
	DWORD dwCWDIllegalInDllSearch = 0;

	WCHAR buf[32] = {0};
	WCHAR errorBuf[MAX_PATH] = {0};

	DWORD dwRet = 0;
	HRESULT hres;

	FILETIME creationTime = {0};
	FILETIME lastAccessTime = {0};
	FILETIME lastWriteTime = {0};
	BOOL success = FALSE;

	HANDLE fileHandle = INVALID_HANDLE_VALUE;
	DWORD fileVersionSize = 0;
	BYTE* versionData = NULL;
	VS_FIXEDFILEINFO *fixedFileInfo = NULL;
	UINT fixedInfoLength = 0;

	dwRet = GetPEHeaderData(filePath, &peInfo);

	if (dwRet == ERROR_SUCCESS)
	{
		is64Bits = (peInfo.Machine == IMAGE_FILE_MACHINE_AMD64 || peInfo.Machine == IMAGE_FILE_MACHINE_IA64);

		hres = g_pWriter->WriteStartElement(NULL, L"app", NULL);
		hres = g_pWriter->WriteAttributeString(NULL, L"path", NULL, filePath);

		swprintf_s(buf, 31, L"%d", peInfo.Machine);
		hres = g_pWriter->WriteElementString(NULL, L"machine", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d", peInfo.Timestamp);
		hres = g_pWriter->WriteElementString(NULL, L"timestamp", NULL, buf); // use time.gmtime or time.localtime/datetime.datetime.fromtimestamp
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d", peInfo.Characteristics);
		hres = g_pWriter->WriteElementString(NULL, L"characteristics", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d", peInfo.Magic);
		hres = g_pWriter->WriteElementString(NULL, L"magic", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d.%d", peInfo.MajorLinker, peInfo.MinorLinker);
		hres = g_pWriter->WriteElementString(NULL, L"linkerVersion", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d.%d", peInfo.MajorOS, peInfo.MinorOS);
		hres = g_pWriter->WriteElementString(NULL, L"osVersion", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d.%d", peInfo.MajorImage, peInfo.MinorImage);
		hres = g_pWriter->WriteElementString(NULL, L"imageVersion", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d.%d", peInfo.MajorSubsystem, peInfo.MinorSubsystem);
		hres = g_pWriter->WriteElementString(NULL, L"subsystemVersion", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d", peInfo.Subsystem);
		hres = g_pWriter->WriteElementString(NULL, L"subsystem", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		swprintf_s(buf, 31, L"%d", peInfo.DllCharacteristics);
		hres = g_pWriter->WriteElementString(NULL, L"dllCharacteristics", NULL, buf);
		SecureZeroMemory(buf, sizeof(buf));

		fileHandle = CreateFile(filePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

		if(INVALID_HANDLE_VALUE == fileHandle) 
		{
			swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: Unable to get file timestamp. CreateFile failed with error %d", GetLastError());
			g_pWriter->WriteComment(errorBuf);
			SecureZeroMemory(errorBuf, sizeof(errorBuf));
		}
		else 
		{
			success = GetFileTime(fileHandle, &creationTime, &lastAccessTime, &lastWriteTime);

			if(success)
			{
				swprintf_s(buf, 31, L"0x%08X%08X", creationTime.dwHighDateTime, creationTime.dwLowDateTime);
				hres = g_pWriter->WriteElementString(NULL, L"creationTimestamp", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));

				swprintf_s(buf, 31, L"0x%08X%08X", lastAccessTime.dwHighDateTime, lastAccessTime.dwLowDateTime);
				hres = g_pWriter->WriteElementString(NULL, L"accessTimestamp", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));

				swprintf_s(buf, 31, L"0x%08X%08X", lastWriteTime.dwHighDateTime, lastWriteTime.dwLowDateTime);
				hres = g_pWriter->WriteElementString(NULL, L"writeTimestamp", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));
			}
			else
			{
				swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: Unable to get file timestamp. GetFileTime failed with error %d", GetLastError());
				g_pWriter->WriteComment(errorBuf);
				SecureZeroMemory(errorBuf, sizeof(errorBuf));
			}

			CloseHandle(fileHandle);
		}
	
		fileVersionSize = GetFileVersionInfoSize(filePath, NULL);

		if(fileVersionSize > 0)
		{
			versionData = new BYTE[fileVersionSize];
			SecureZeroMemory(versionData, fileVersionSize);

			if (versionData != NULL)
			{
				success = GetFileVersionInfo(filePath, NULL, fileVersionSize, versionData); 

				if(success)
				{
					success = VerQueryValue(versionData, L"\\", (LPVOID *)&fixedFileInfo, &fixedInfoLength);

					if (success)
					{
						swprintf_s(buf, 31, L"%d.%d.%d.%d", HIWORD(fixedFileInfo->dwFileVersionMS), LOWORD(fixedFileInfo->dwFileVersionMS), HIWORD(fixedFileInfo->dwFileVersionLS), LOWORD(fixedFileInfo->dwFileVersionLS));
						hres = g_pWriter->WriteElementString(NULL, L"fileVersion", NULL, buf);
						SecureZeroMemory(buf, sizeof(buf));

						swprintf_s(buf, 31, L"%d.%d.%d.%d", HIWORD(fixedFileInfo->dwProductVersionMS), LOWORD(fixedFileInfo->dwProductVersionMS), HIWORD(fixedFileInfo->dwProductVersionLS), LOWORD(fixedFileInfo->dwProductVersionLS));
						hres = g_pWriter->WriteElementString(NULL, L"productVersion", NULL, buf);
						SecureZeroMemory(buf, sizeof(buf));
					}
					else
					{
						swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: Unable to get file version information. VerQueryValue failed with error %d", GetLastError());
						g_pWriter->WriteComment(errorBuf);
						SecureZeroMemory(errorBuf, sizeof(errorBuf));
					}
				}
				else
				{
					swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: Unable to get file version information. GetFileVersionInfo failed with error %d", GetLastError());
					g_pWriter->WriteComment(errorBuf);
					SecureZeroMemory(errorBuf, sizeof(errorBuf));
				}

				SecureZeroMemory(versionData, fileVersionSize);
				delete[] versionData;
				versionData = NULL;
			}
			else
			{
				swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: Unable to get file version information. Could not allocate memory");
				g_pWriter->WriteComment(errorBuf);
				SecureZeroMemory(errorBuf, sizeof(errorBuf));
			}
		}

		dwRet = GetAppCompatDEPSetting(filePath, is64Bits, &pSetting);

		if (dwRet == ERROR_SUCCESS)
		{
			hres = g_pWriter->WriteElementString(NULL, L"appCompat", NULL, pSetting);
			free(pSetting);
		}

		dwRet = GetAppIFEOMitigations(
			filePath,
			is64Bits,
			&dwConfiguredMitigations,
			&dwExecuteOptions,
			&qwMitigationOptions,
			&dwDisableExceptionChainValidation,
			&dwEnableLowVaAccess,
			&dwCWDIllegalInDllSearch
			);


		if (dwRet == ERROR_SUCCESS)
		{
			if (dwConfiguredMitigations & IFEO_EXECUTEOPTIONS_EXISTS)
			{
				swprintf_s(buf, 31, L"0x%08X", dwExecuteOptions);
				hres = g_pWriter->WriteElementString(NULL, L"executeOptions", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));
			}

			if (dwConfiguredMitigations & IFEO_MITIGATIONOPTIONS_EXISTS)
			{
				swprintf_s(buf, 31, L"0x%016llX", qwMitigationOptions);
				hres = g_pWriter->WriteElementString(NULL, L"mitigationOptions", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));
			}

			if (dwConfiguredMitigations & IFEO_DISABLEEXCEPTIONCHAINVALIDATION_EXISTS)
			{
				swprintf_s(buf, 31, L"0x%08X", dwDisableExceptionChainValidation);
				hres = g_pWriter->WriteElementString(NULL, L"disabledExceptionChainValidation", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));
			}

			if (dwConfiguredMitigations & IFEO_ENABLELOWVAACCESS_EXISTS)
			{
				swprintf_s(buf, 31, L"0x%08X", dwEnableLowVaAccess);
				hres = g_pWriter->WriteElementString(NULL, L"enableLowVaAccess", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));
			}

			if (dwConfiguredMitigations & IFEO_CWDILLEGALINDLLSEARCH)
			{
				swprintf_s(buf, 31, L"0x%08X", dwCWDIllegalInDllSearch);
				hres = g_pWriter->WriteElementString(NULL, L"cwdIllegalInDllSearch", NULL, buf);
				SecureZeroMemory(buf, sizeof(buf));
			}
		}

		hres = g_pWriter->WriteEndElement();
		hres = g_pWriter->Flush();
	}
	else
	{
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetPEHeaderData failed with error %d", GetLastError());
		g_pWriter->WriteComment(errorBuf);
		SecureZeroMemory(errorBuf, sizeof(errorBuf));
	}
}

// Recursive directory traversal function
// that looks for a specified file. If it finds
// the file it calls the callback.

DWORD SearchDirectoryTreeForFile(
	LPWSTR dirPath,
	LPWSTR soughtFile,
	DWORD currDepth, 
	DWORD maxDepth,
	TRAVERSAL_CALLBACK callback
	)
{
	WCHAR path[MAX_PATH] = { 0 };
	WIN32_FIND_DATAW findData = { 0 };
	DWORD err = 0;
	BOOL bRet = FALSE;
	DWORD dwRet = 0;

	if (currDepth > maxDepth) 
		return ERROR_SUCCESS;


	// If the path is longer than MAX_PATH, bail out without
	// an error because we want to continue enumerating those
	// files and directories whose paths do not overflow our 
	// buffer.

	if (0 > swprintf_s(path, MAX_PATH - 1, L"%s\\*", dirPath))
		return ERROR_SUCCESS;


	HANDLE hFind = FindFirstFileW(path, &findData);
	bRet = (hFind != INVALID_HANDLE_VALUE);

	while (bRet)
	{
		// Skip reparse points, since those can lead to infinite loops.
		if (findData.dwFileAttributes != FILE_ATTRIBUTE_REPARSE_POINT)
		{
			SecureZeroMemory(path, sizeof(path));

			// Skip the . and .. directories and skip this entry if its full path overflows our buffer.
			if (0 != wcscmp(findData.cFileName, L".") &&
				0 != wcscmp(findData.cFileName, L"..") &&
				0 < swprintf_s(path, MAX_PATH - 1, L"%s\\%s", dirPath, findData.cFileName))
			{

				// If it's a directory, traverse it.
				if (findData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
				{
					dwRet = SearchDirectoryTreeForFile(
						path,
						soughtFile,
						currDepth + 1,
						maxDepth, 
						callback
						);
					if (dwRet != ERROR_SUCCESS)
					{
						FindClose(hFind);
						return dwRet;
					}
				}

				// Else if it's the file we're looking for, call the callback
				else if (0 == _wcsicmp(soughtFile, findData.cFileName))
				{
					callback(path);
				}
			}
		}

		SecureZeroMemory(&findData, sizeof(findData));
		bRet = FindNextFile(hFind, &findData);
	};

	err = GetLastError();

	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);

	if (err == ERROR_NO_MORE_FILES || err == ERROR_FILE_NOT_FOUND )
		return ERROR_SUCCESS;

	return err;
}

// Assumes globals g_osArch and g_pWriter have been set.
VOID OutputAppMitigations()
{
	DWORD numApps = sizeof(appsToCheck) / sizeof(appsToCheck[0]);
	WCHAR progFile[2][MAX_PATH] = { 0 };
	WCHAR dirPath[MAX_PATH] = { 0 };
	DWORD appIndex = 0;
	DWORD progFileDirIndex = 0;
	DWORD maxProgFiles = 0;
	BOOL bIs64Bits = TRUE;

	__try
	{

		if (g_osArch == PROCESSOR_ARCHITECTURE_INTEL ||
			g_osArch == PROCESSOR_ARCHITECTURE_ARM)
		{
			bIs64Bits = FALSE;
		}

		if (bIs64Bits)
		{
			if (ExpandEnvironmentStringsW(L"%ProgramFiles(x86)%", progFile[0], MAX_PATH - 1))
				maxProgFiles = 1;

			if (ExpandEnvironmentStringsW(L"%ProgramW6432%", progFile[1], MAX_PATH - 1))
				maxProgFiles = 2;
		}
		else 
		{
			if (ExpandEnvironmentStringsW(L"%ProgramFiles%", progFile[0], MAX_PATH - 1))
				maxProgFiles = 1;
		}

		for (progFileDirIndex = 0; progFileDirIndex < maxProgFiles; progFileDirIndex++)
		{
			for (appIndex = 0; appIndex < numApps; appIndex++)
			{
				SecureZeroMemory(dirPath, sizeof(dirPath));
				swprintf_s(dirPath, MAX_PATH - 1, L"%s\\%s", progFile[progFileDirIndex], appsToCheck[appIndex][0]);

				SearchDirectoryTreeForFile(
					dirPath,
					appsToCheck[appIndex][1],
					1,
					6, // MAX depth
					OutputAppMitigations_callback
					);
			}
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputAppMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}
}

// This routine tests whether it is possible to map the NULL page. This
// is commonly used in NULL pointer deference exploits.
BOOL TestMapNullPage()
{
	NTSTATUS(NTAPI *NtAllocateVirtualMemory)(
		HANDLE hProcess,
		PVOID *baseAddress,
		ULONG zeroBits,
		PULONG allocationSize,
		ULONG allocationType,
		ULONG protect
		);

	PVOID baseAddress = (PVOID)1;
	ULONG allocationSize = 0x1000;
	NTSTATUS status;
	BOOL retval = FALSE;

	*((PVOID *)&NtAllocateVirtualMemory) = GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory)
	{
		status = NtAllocateVirtualMemory(
			GetCurrentProcess(),
			&baseAddress,
			0,
			&allocationSize,
			MEM_RESERVE | MEM_COMMIT,
			PAGE_EXECUTE_READWRITE
			);

		if (status >= 0 && !baseAddress)
		{
			// Verify we can actually write to the NULL page.
			DWORD *pNullPage = NULL;
			__try
			{
				*pNullPage = 7;
				retval = TRUE;
			}
			__except (EXCEPTION_EXECUTE_HANDLER){}

		}
	}

	return retval;
}

void OutputHotfixes(IWbemServices *pSvc)
{
	// Record presence of hotfixes we are interested in due to them introducing a feature (or supersedes as patch which introduced the feature)

	__try
	{

		LPWSTR hotFixIdsArray[] =
		{
			L"KB3000850", // Control Flow Guard patch, no superseded patches
			L"KB2919355", L"KB2893294", //Certificate Padding patch is KB2893294, plus superseded patches
			L"KB3035131", L"KB3045999", L"KB3000483", L"KB3031432", L"KB3023266", L"KB2839229", L"KB2859537", L"KB2872339", L"KB2829361", L"KB3033395", L"KB2813170", // kernel null page patch is KB2813170, plus superseded patches
			L"KB2859537", L"KB3045999", L"KB2264107", // Secure Search Path patch is KB2264107, plus superseded patches
			L"KB3031432", L"KB2859537", L"KB2872339", L"KB2799494", L"KB3004375", L"KB2676562", L"KB3022345", L"KB2882822", L"KB3023266", L"KB3033929", L"KB2839229", L"KB3046480", L"KB2871997", L"KB3000483", L"KB2813170", L"KB2724197", L"KB3035131", L"KB3045999", L"KB2949927", L"KB2679255", L"KB2639308", // ForceASLR patch is KB2639308, plus superseded patches
		};

		BOOL isPresentArray[sizeof(hotFixIdsArray) / sizeof(hotFixIdsArray[0])];

		HRESULT hres = CheckforPatches(
			pSvc,
			hotFixIdsArray,
			sizeof(hotFixIdsArray) / sizeof(hotFixIdsArray[0]),
			isPresentArray
			);

		if (SUCCEEDED(hres))
		{
			for (DWORD i = 0; i < sizeof(hotFixIdsArray) / sizeof(hotFixIdsArray[0]); i++)
			{
				if (isPresentArray[i])
					g_pWriter->WriteElementString(NULL, L"hotfix", NULL, hotFixIdsArray[i]);
			}
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputHotfixes threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}
}

VOID OutputSystemMitigations()
{
	DWORD size = 0;
	DWORD dwRet = 0;
	WCHAR buf[MAX_PATH] = { 0 };

	__try
	{
		BOOL cfgEnabled = FALSE;
		DWORD result = 0;

		result = GetControlFlowGuard(&cfgEnabled);

		if (ERROR_SUCCESS == result) {
			LPWSTR toWrite = (cfgEnabled ? L"YES" : L"NO");

			g_pWriter->WriteElementString(NULL, L"cfg", NULL, toWrite);
			g_pWriter->Flush();
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetControlFlowGuard threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	__try 
	{
		LPWSTR firmwareType = NULL;

	    DWORD result = GetFirmwareType(&firmwareType);

		if (ERROR_SUCCESS == result)
		{
			LPWSTR toWrite = (firmwareType ? firmwareType : L"");

			g_pWriter->WriteElementString(NULL, L"firmwareType", NULL, toWrite);
			g_pWriter->Flush();
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetFirmwareType threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	__try
	{
		DWORD value = 0;
		DWORD result = GetMemoryOverwriteRequestControlVariableData(L"MemoryOverwriteRequestControl", L"{E20939BE-32D4-41BE-A150-897F85D49829}", &value);
		
		if (ERROR_SUCCESS == result)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"%lu", value);
			g_pWriter->WriteElementString(NULL, L"memoryOverwriteRequestControl", NULL, buf);
			g_pWriter->Flush();
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetMemoryOverwriteRequestControl threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	__try
	{
		DWORD value = 0;
		DWORD result = GetMemoryOverwriteRequestControlVariableData(L"MemoryOverwriteRequestControlLock", L"{BB983CCF-151D-40E1-A07B-4A17BE168292}", &value);

		if (ERROR_SUCCESS == result)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"%lu", value);
			g_pWriter->WriteElementString(NULL, L"memoryOverwriteRequestControlLock", NULL, buf);
			g_pWriter->Flush();
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetMemoryOverwriteRequestControlLock threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	__try 
	{
		BOOL secureBootEnabled = FALSE;

	    secureBootEnabled = GetSecureBootEnabled();
		LPWSTR toWrite = (secureBootEnabled ? L"YES" : L"NO");

		g_pWriter->WriteElementString(NULL, L"secureBoot", NULL, toWrite);
		g_pWriter->Flush();
	}
	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetSecureBootEnabled threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	__try 
	{
		DWORD fontBlocking = 0;

		fontBlocking = GetFontBlocking();

		if(fontBlocking >= 1 && fontBlocking <= 3)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"%lu", fontBlocking);
			g_pWriter->WriteElementString(NULL, L"fontBlocking", NULL, buf);
			g_pWriter->Flush();
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER) 
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: GetFontBlocking threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	__try
	{
		DEP_SYSTEM_POLICY_TYPE policy = DEPTotalPolicyCount;
		dwRet = GetDepPolicy(&policy);
		if (dwRet == ERROR_SUCCESS && policy < DEPTotalPolicyCount && policy < 4)
		{
			PWCHAR policyNames[] =
			{
				L"AlwaysOff",
				L"AlwaysOn",
				L"OptIn",
				L"OptOut"
			};
			g_pWriter->WriteElementString(NULL, L"depPolicy", NULL, policyNames[policy]);
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	// Get OS wide MitigationOptions

	__try
	{
		LARGE_INTEGER qwMitigationOptions = { 0 };
		size = sizeof(qwMitigationOptions);

		dwRet = ReadHKLMRegistryValue(
			L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Kernel",
			L"MitigationOptions",
			(LPBYTE)&qwMitigationOptions.QuadPart,
			&size
			);

		if (dwRet == ERROR_SUCCESS)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"0x%08X%08X", qwMitigationOptions.HighPart, qwMitigationOptions.LowPart);
			g_pWriter->WriteElementString(NULL, L"mitigationOptions", NULL, buf);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	// Get OS wide SEHOP DisableExceptionChainValidation

	__try
	{
		DWORD dwDisableExceptionChainValidation = 0;
		size = sizeof(dwDisableExceptionChainValidation);

		dwRet = ReadHKLMRegistryValue(
			L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Kernel",
			L"DisableExceptionChainValidation",
			(LPBYTE)&dwDisableExceptionChainValidation,
			&size
			);

		if (dwRet == ERROR_SUCCESS)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"0x%08X", dwDisableExceptionChainValidation);
			g_pWriter->WriteElementString(NULL, L"disableExceptionChainValidation", NULL, buf);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}


	// Get Kernel SEHOP mitigation  (really only matters for Windows 8.1+ x86)

	__try
	{
		DWORD dwKernelSEHOPEnabled = 0;
		size = sizeof(dwKernelSEHOPEnabled);

		dwRet = ReadHKLMRegistryValue(
			L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Kernel",
			L"KernelSEHOPEnabled",
			(LPBYTE)&dwKernelSEHOPEnabled,
			&size
			);

		if (dwRet == ERROR_SUCCESS)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"0x%08X", dwKernelSEHOPEnabled);
			g_pWriter->WriteElementString(NULL, L"kernelSEHOPEnabled", NULL, buf);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	// Get kernel null page mitigation aka EnableLowVaAccess

	__try
	{
		DWORD dwEnableLowVaAccess = 0;
		size = sizeof(dwEnableLowVaAccess);

		dwRet = ReadHKLMRegistryValue(
			L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
			L"EnableLowVaAccess",
			(LPBYTE)&dwEnableLowVaAccess,
			&size
			);

		if (dwRet == ERROR_SUCCESS)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"0x%08X", dwEnableLowVaAccess);
			g_pWriter->WriteElementString(NULL, L"enableLowVaAccess", NULL, buf);
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	// Record whether it is possible to map the NULL page.

	__try
	{
		SecureZeroMemory(buf, sizeof(buf));
		swprintf_s(buf, MAX_PATH - 1, L"%s", (TestMapNullPage() ? L"YES" : L"NO"));
		g_pWriter->WriteElementString(NULL, L"ableToMapNullPage", NULL, buf);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(buf);
	}

	// Get OS ASLR via MoveImages

	__try
	{
		DWORD dwMoveImages = 0;
		size = sizeof(dwMoveImages);

		dwRet = ReadHKLMRegistryValue(
			L"SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management",
			L"MoveImages",
			(LPBYTE)&dwMoveImages,
			&size
			);

		if (dwRet == ERROR_SUCCESS)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"0x%08X", dwMoveImages);
			g_pWriter->WriteElementString(NULL, L"moveImages", NULL, buf);
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	// Get EnableCertPadding

	__try
	{
		DWORD dwCertPadding = 0;
		size = sizeof(dwCertPadding);
		dwRet = ReadHKLMRegistryValue(
			L"SOFTWARE\\Microsoft\\Cryptography\\Wintrust\\Config",
			L"EnableCertPaddingCheck",
			(LPBYTE)&dwCertPadding,
			&size
			);

		if (dwRet == ERROR_SUCCESS) 
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"%d", dwCertPadding);
			g_pWriter->WriteElementString(NULL, L"enableCertPaddingCheck", NULL, buf);
		}


		dwCertPadding = 0;
		size = sizeof(dwCertPadding);

		dwRet = ReadHKLMRegistryValue(
			L"SOFTWARE\\Wow6432Node\\Microsoft\\Cryptography\\Wintrust\\Config",
			L"EnableCertPaddingCheck",
			(LPBYTE)&dwCertPadding,
			&size
			);

		if (dwRet == ERROR_SUCCESS) 
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"%d", dwCertPadding);
			g_pWriter->WriteElementString(NULL, L"enableCertPaddingCheck_wow64", NULL, buf);
		}

	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}

	// Get Safe Search Path CWDIllegalInDllSearch

	__try
	{

		DWORD dwCWDIllegalInDllSearch = 0;
		size = sizeof(dwCWDIllegalInDllSearch);

		dwRet = ReadHKLMRegistryValue(
			L"SYSTEM\\CurrentControlSet\\Control\\Session Manager",
			L"CWDIllegalInDllSearch",
			(LPBYTE)&dwCWDIllegalInDllSearch,
			&size
			);

		if (dwRet == ERROR_SUCCESS)
		{
			SecureZeroMemory(buf, sizeof(buf));
			swprintf_s(buf, MAX_PATH - 1, L"0x%08X", dwCWDIllegalInDllSearch);
			g_pWriter->WriteElementString(NULL, L"cwdIllegalInDllSearch", NULL, buf);
		}
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		WCHAR errorBuf[MAX_PATH] = { 0 };
		swprintf_s(errorBuf, MAX_PATH - 1, L"ERROR: OutputSystemMitigations threw exception 0x%08X", GetExceptionCode());
		g_pWriter->WriteComment(errorBuf);
	}
}


int _tmain(void)
{
	HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0);

	HRESULT hres;
	IWbemLocator *pLoc = NULL;
	IWbemServices *pSvc = NULL;

	IStream *pOutFileStream = NULL;
	IXmlWriter *pWriter = NULL;

	SYSTEM_INFO si = { 0 };
	
	GetNativeSystemInfo(&si);
	g_osArch = si.wProcessorArchitecture;

	hres = CoInitializeEx(0, COINIT_MULTITHREADED);

	if (FAILED(hres))
		return hres;

	hres = CoInitializeSecurity(
		NULL,
		-1,                          // COM authentication
		NULL,                        // Authentication services
		NULL,                        // Reserved
		RPC_C_AUTHN_LEVEL_DEFAULT,   // Default authentication 
		RPC_C_IMP_LEVEL_IMPERSONATE, // Default Impersonation  
		NULL,                        // Authentication info
		EOAC_NONE,                   // Additional capabilities 
		NULL                         // Reserved
		);

	if (FAILED(hres))
		goto DONE;


	hres = CoCreateInstance(
		CLSID_WbemLocator,
		0,
		CLSCTX_INPROC_SERVER,
		IID_IWbemLocator, (LPVOID *)&pLoc);

	if (FAILED(hres))
		goto DONE;


	hres = pLoc->ConnectServer(
		_bstr_t(L"ROOT\\CIMV2"), // Object path of WMI namespace
		NULL,                    // User name. NULL = current user
		NULL,                    // User password. NULL = current
		0,                       // Locale. NULL indicates current
		NULL,                    // Security flags.
		0,                       // Authority (e.g. Kerberos)
		0,                       // Context object 
		&pSvc                    // pointer to IWbemServices proxy
		);

	if (FAILED(hres))
		goto DONE;

	hres = CoSetProxyBlanket(
		pSvc,                        // Indicates the proxy to set
		RPC_C_AUTHN_WINNT,           // RPC_C_AUTHN_xxx
		RPC_C_AUTHZ_NONE,            // RPC_C_AUTHZ_xxx
		NULL,                        // Server principal name 
		RPC_C_AUTHN_LEVEL_CALL,      // RPC_C_AUTHN_LEVEL_xxx 
		RPC_C_IMP_LEVEL_IMPERSONATE, // RPC_C_IMP_LEVEL_xxx
		NULL,                        // client identity
		EOAC_NONE                    // proxy capabilities 
		);

	if (FAILED(hres))
		goto DONE;

	pOutFileStream = new FileStream(GetStdHandle(STD_OUTPUT_HANDLE));

	if (!pOutFileStream)
	{
		hres = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
		goto DONE;
	}

	hres = CreateXmlWriter(__uuidof(IXmlWriter), (void**)&pWriter, NULL);

	if (FAILED(hres))
		goto DONE;

	g_pWriter = pWriter;

	hres = pWriter->SetOutput(pOutFileStream);

	if (FAILED(hres))
		goto DONE;

	hres = pWriter->SetProperty(XmlWriterProperty_Indent, TRUE);

	if (FAILED(hres))
		goto DONE;

	hres = pWriter->SetProperty(XmlWriterProperty_OmitXmlDeclaration, FALSE);

	if (FAILED(hres))
		goto DONE;

	hres = pWriter->WriteStartDocument(XmlStandalone_Omit);

	if (FAILED(hres))
		goto DONE;

	pWriter->WriteStartElement( NULL, L"antiExploitation", NULL);

	pWriter->WriteStartElement(NULL, L"hardwareSupport", NULL);
	FEATURE_SUPPORT pae, nx, smep, smap;
	GetAntiExHWSupport(&pae, &nx, &smep, &smap);
	pWriter->WriteElementString(NULL, L"pae", NULL, (pae ? L"YES" : L"NO"));
	pWriter->WriteElementString(NULL, L"nx", NULL, (nx ? L"YES" : L"NO"));
	pWriter->WriteElementString(NULL, L"smep", NULL, (smep ? L"YES" : L"NO"));
	pWriter->WriteElementString(NULL, L"smap", NULL, (smap ? L"YES" : L"NO"));
	pWriter->WriteEndElement();
	pWriter->Flush();

	pWriter->WriteStartElement(NULL, L"hotfixes", NULL);
	OutputHotfixes(pSvc);
	pWriter->WriteEndElement();
	pWriter->Flush();

	pWriter->WriteStartElement(NULL, L"systemMitigations", NULL);
	OutputSystemMitigations();
	pWriter->WriteEndElement();
	pWriter->Flush();

	pWriter->WriteStartElement(NULL, L"appMitigations", NULL);
	OutputAppMitigations();
	pWriter->WriteEndElement();
	pWriter->Flush();

	pWriter->WriteEndElement();
	pWriter->Flush();

	hres = S_OK;

DONE:

	if (pWriter)
		pWriter->WriteEndDocument();

	if (pWriter)
		pWriter->Flush();

	SAFE_RELEASE(pOutFileStream);
	SAFE_RELEASE(pWriter);

	if (pSvc)
		pSvc->Release();

	if (pLoc)
		pLoc->Release();

	CoUninitialize();

	return (int)hres;
}
